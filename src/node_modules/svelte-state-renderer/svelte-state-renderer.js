import { tick } from 'svelte'

import View from './View.svelte'

View.from = (target, asr) => {
  if (target instanceof HTMLElement) {
    // it's a target element
    return new View({ target, props: { asr }  })
  } else {
    // it's alreay a View
    return target
  }
}

const ASR = Symbol('asr')

const hijackStateRouter = stateRouter => {
  const { addState: superAddState, } = stateRouter

  const resolveComponent = template => {
    if (typeof template === 'function') {
      return template()
    } else {
      return template.component()
    }
  }

  const addState = ({ register, template, ...config }) => {
    const convertedCfg = {
      ...config,
      template,
      async resolve(...args) {
        const Cmp = await resolveComponent(template)
        if (Cmp.resolve) {
          return Cmp.resolve(...args)
        }
        return null
      },
    }
    superAddState(convertedCfg)
    if (register) {
      addStates(register)
    }
  }

  const addStates = (...states) =>
    states.forEach(arg => {
      if (Array.isArray(arg)) {
        arg.forEach(states => addStates(states))
      } else {
        addState(arg)
      }
    })

  Object.assign(stateRouter, { addState, addStates })
}

export default (defaultOptions = {}) => stateRouter => {
  hijackStateRouter(stateRouter)

  const { props: defaultProps } = defaultOptions

  const asr = {
    makePath: stateRouter.makePath,
    stateIsActive: stateRouter.stateIsActive,
    go: stateRouter.go,
  }

  const render = async context => {
    const { element: target, template, content } = context
    const props = { ...content, ...defaultProps }

    const view = View.from(target, asr)

    const construct = async (getComponent, props) => {
      const { default: Component } = await getComponent()
      const component = await view.setComponent(Component, props)
      return component
    }

    let cmp

    if (typeof template === `function`) {
      cmp = await construct(template, props)
    } else {
      cmp = await construct(template.component, { ...props, ...template.props })
    }

    function onRouteChange() {
      // FIXME what's this? force refresh? why?
      // cmp.$set({ asr })
    }

    stateRouter.on(`stateChangeEnd`, onRouteChange)

    const onDestroy = () =>
      stateRouter.removeListener(`stateChangeEnd`, onRouteChange)

    cmp[ASR] = { view, onDestroy }

    return cmp
  }

  return {
    render,
    async reset(context, cb) {
      const cmp = context.domApi
      const { view, onDestroy } = cmp[ASR]
      onDestroy()
      const renderContext = { ...context, element: view }
      return render(renderContext, cb)
    },
    async destroy(cmp) {
      const { view, onDestroy } = cmp[ASR]
      onDestroy()
      view.$destroy()
      await tick()
    },
    async getChildElement(cmp) {
      const { [ASR]: {view} } = cmp
      return view.getChild()
    },
  }
}
